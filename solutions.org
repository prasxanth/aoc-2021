#+TITLE:     Advent of Code: 2021
#+AUTHOR:    Prashanth Kumar
#+DATE:      2021-12-01
#+EMAIL:     prasxanth.kumar@gmail.com
#+LANGUAGE:  en

#+INFOJS_OPT: view:info toc:t tdepth:2 sdepth:1 ltoc:nil mouse:underline path:org-info.js buttons:t

#+PROPERTY: header-args:J  :session *aoc2021* :eval never-export

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org.css"/>
#+EXPORT_FILE_NAME: docs/index.html
#+EXPORT_EXCLUDE_TAGS: noexport

#+OPTIONS: ':t *:t -:t ::t <:t H:4 \n:nil ^:t arch:headline author:t c:nil
#+OPTIONS: creator:comment d:(not LOGBOOK) date:t e:t email:nil f:t inline:t
#+OPTIONS: num:nil p:nil pri:nil stat:t tags:t tasks:t tex:t timestamp:t toc:t

** Initializations                                                 :noexport:

*** Set working directory path

#+NAME: setwd
#+BEGIN_SRC j :results output
  (1!:44) (jpath '~/Documents/advent-of-code-2021/')
  load <'utils.ijs'  NB. readin
  getcwd ''
#+END_SRC

#+RESULTS: setwd
: /mnt/c/Users/pkumar162722/OneDrive - Applied Materials/Scratch/Analytics Exercises/Scripts/advent-of-code-2021

** About
Solutions to [[https://adventofcode.com/2021][Advent of Code: 2021]] in the array programming language [[https://www.jsoftware.com/#/][J]]. 

Language and IDE details,

| Engine    | *j901/j64/linux*                 |
| Release-c | *commercial/2020-01-11T10:39:00* |
| Library   | *9.01.24*                        |
| Qt IDE    | *1.8.7/5.7.1(5.9.5)*             |
| Platform  | *Linux 64*                       |

*** Conventions

**** General

#+begin_note
Before we start, I should point out a convention of J: if a dyadic verb is asymmetric, 
for mnemonic purposes you should think of x as operating on y.  One way to express this is to say that x is control 
information and y is data.  Another way is to say that if you were applying the verb many times, you would expect to 
apply the same x to different ys rather than the other way around.

-- https://www.jsoftware.com/help/jforc/more_verbs.htm
#+end_note

**** Naming
  + All variable and function names are lower case and do /not/ include any underscores
  + All variable and function names, in tacit and explicit definitions, are at least two characters long to avoid confusion with 
    built-in single character J verbs. Exceptions to this are for variables defined in,
    - Single line quoted expressions
    - Anonymous verbs

**** AOC specific

| Convention                   | Type              | Description                                               | Example                                   |
|------------------------------+-------------------+-----------------------------------------------------------+-------------------------------------------|
| =getin=                      | Monadic function  | Read and process data from input file                     | =getin =: ;: readin=                      |
| =in=                         | Variable          | Input data for problem                                    | =in =: getin 'inputs/day-01.txt'=         |
| =inx=; =inx1=; =inx2=; =...= | Variable(s)       | Example input data for problem                            | =inx =: getin 'inpus/day-01-example.txt'= |
| =part1=; =part2=            | Monadic functions | Solutions to respective parts of problems with =y = data= | =part1 in=                                |

#+begin_attention
General functions that would be useful beyond the scope of the solution are indicated with the ❖ symbol.
#+end_attention

The approach to formulating solutions is as follows,

+ To the extent possible, function definitions are general enough for use in both parts of the problem.
+ Each part should be independently executable, that is, it should not rely on any results from the other part.

*** Site

This site was generated using *Emacs 26.3* with *Org mode 9.1.9*. A custom CSS and [[https://orgmode.org/worg/code/org-info-js/][Org-Info.JS]] were used to style the exported HTML.

This site is best viewed with [[https://fonts.google.com/specimen/Fira+Sans][Fira Sans]] and [[https://fonts.google.com/specimen/Fira+Code][Fira Code]] fonts.

** [[https://adventofcode.com/2021/day/1][Day 01: Sonar Sweep]]

#+TOC: headlines 2 local

*** Setup

#+BEGIN_SRC j :results output silent
cocurrent <'day01'
#+END_SRC

#+BEGIN_SRC j :results output silent :tangle src/day01.ijs
load <'utils.ijs'  NB. readin
#+END_SRC

*** Read data

#+BEGIN_SRC j :results output silent :tangle src/day01.ijs
getin=: ". readin
#+END_SRC

*** General function definition

Generic function to calculate number of increases in data for a given moving window size,
#+BEGIN_SRC j :results output silent :tangle src/day01.ijs 
NB. Calculate number of increases
NB. y = data
NB. x = moving window size
ninc=: +/ @ (2 </\ +/\)
#+END_SRC

*** Part 1

**** Function definition

#+BEGIN_SRC j :results output silent :tangle src/day01.ijs
part1=: 1&ninc
#+END_SRC

**** Test

#+BEGIN_SRC j :results output value :tangle src/day01.ijs
assert 7 = part1 inx=. getin 'inputs/day-01-example.txt'
#+END_SRC

#+RESULTS:

**** Solution

#+BEGIN_SRC j :results output value :tangle src/day01.ijs
assert 1602 = part1 in=. getin 'inputs/day-01.txt'
#+END_SRC

#+RESULTS:

*** Part 2

**** Function definition

#+BEGIN_SRC j :results output silent :tangle src/day01.ijs
part2=: 3&ninc
#+END_SRC

**** Test

#+BEGIN_SRC j :results output value :tangle src/day01.ijs
assert 7 = part1 inx=. getin 'inputs/day-01-example.txt'
#+END_SRC

#+RESULTS:

**** Solution

#+BEGIN_SRC j :results output value :tangle src/day01.ijs
assert 1633 = part2 in=. getin 'inputs/day-01.txt'
#+END_SRC

#+RESULTS:

** [[https://adventofcode.com/2021/day/2][Day 02: Dive!]]

#+TOC: headlines 2 local

*** Setup

#+BEGIN_SRC j :results output silent
cocurrent <'day02'
#+END_SRC

#+BEGIN_SRC j :results output silent :tangle src/day02.ijs
load <'utils.ijs'  NB. readin
#+END_SRC

*** Read data

#+BEGIN_SRC j :results output silent :tangle src/day02.ijs
getin=: ;: readin
#+END_SRC

*** General function definition


***** Directions

#+BEGIN_SRC j :results output silent :tangle src/day02.ijs
NB. Displacement vectors
NB. y = input
NB. Returns three column boolean mask matrix of size (|. $ y)
NB. for each direction
dirxns=: ('forward'; 'up'; 'down') E./"0 1 {."1
#+END_SRC

***** Displacements

#+BEGIN_SRC j :results output silent :tangle src/day02.ijs
NB. Horizontal and vertical displacement vectors
NB. y = input
NB. Returns two column matrix
NB.   - Column 1 = horizonal displacement = forward
NB.   - Column 2 = vertical displacement = down - up
disp=: [: ({. ,. [: -/|.@}.) (".@>@{:"1@]) *"1 dirxns
#+END_SRC

Reading from right to left, =disp= works as follows,

+ =(".@>@{:"1@]) *"1 dirxns=: Displacements corresponding to each direction.
+ =({. ,. [: -/|.@}.)=: Forward (horizontal) stitched with vertical, =down - up=, displacement.

#+BEGIN_SRC j :results output value :exports results
3 : 0''
y=. getin 'inputs/day-02-example.txt'
g=. (".&.> ,:~ ]) ('y'; '(d=. dirxns) y'; '((".@>@{:"1) *"1 d) y'; 'disp y')
smoutput g
)
#+END_SRC

#+RESULTS:
#+begin_example
┌───────────┬──────────────┬─────────────────────┬──────┐
│y          │(d=. dirxns) y│((".@>@{:"1) *"1 d) y│disp y│
├───────────┼──────────────┼─────────────────────┼──────┤
│┌───────┬─┐│1 0 1 0 0 1   │5 0 8 0 0 2          │5  0  │
││forward│5││0 0 0 1 0 0   │0 0 0 3 0 0          │0  5  │
│├───────┼─┤│0 1 0 0 1 0   │0 5 0 0 8 0          │8  0  │
││down   │5││              │                     │0 _3  │
│├───────┼─┤│              │                     │0  8  │
││forward│8││              │                     │2  0  │
│├───────┼─┤│              │                     │      │
││up     │3││              │                     │      │
│├───────┼─┤│              │                     │      │
││down   │8││              │                     │      │
│├───────┼─┤│              │                     │      │
││forward│2││              │                     │      │
│└───────┴─┘│              │                     │      │
└───────────┴──────────────┴─────────────────────┴──────┘
#+end_example

*** Part 1

**** Function definition

#+BEGIN_SRC j :results output silent :tangle src/day02.ijs
part1=: 3 : '+/ h * +/ v [ v=. {:"1 d [ h=. {."1 d [ d=. disp y'
#+END_SRC

**** Test

#+BEGIN_SRC j :results output value :tangle src/day02.ijs
assert 150 = part1 inx=. getin 'inputs/day-02-example.txt'
#+END_SRC

#+RESULTS:

**** Solution
    
#+BEGIN_SRC j :results output scalar value :tangle src/day02.ijs
assert 1868935 = part1 in=. getin 'inputs/day-02.txt'
#+END_SRC

#+RESULTS:

*** Part 2

**** Function definition

#+BEGIN_SRC j :results output silent :tangle src/day02.ijs
part2=: 3 : '+/ h * +/ h * +/\ v [ v=. {:"1 d [ h=. {."1 d [ d=. disp y'
#+END_SRC

**** Test

#+BEGIN_SRC j :results output value :tangle src/day02.ijs
assert 900 = part2 inx=. getin 'inputs/day-02-example.txt'
#+END_SRC

#+RESULTS:

**** Solution

#+BEGIN_SRC j :results output scalar value :tangle src/day02.ijs
assert 1965970888 = part2 in=. getin 'inputs/day-02.txt'
#+END_SRC

#+RESULTS:

** [[https://adventofcode.com/2021/day/3][Day 03: Binary Diagnostic]]

#+TOC: headlines 2 local

*** Setup
   
#+BEGIN_SRC j :results output silent
cocurrent <'day03'
#+END_SRC

#+BEGIN_SRC j :results output silent :tangle src/day03.ijs
load <'utils.ijs'  NB. readin
#+END_SRC

*** Read data

#+BEGIN_SRC j :results output silent :noweb yes :tangle src/day03.ijs
getin=: "."0 readin
#+END_SRC

*** Part 1
**** Function definition

#+BEGIN_SRC j :results output silent :tangle src/day03.ijs
part1=: (*&:#. -.)@(-:@# < +/)  NB. (epsilon =: -. gamma)
#+END_SRC

**** Test
#+BEGIN_SRC j :results output value :tangle src/day03.ijs
assert 198 = part1 inx=. getin 'inputs/day-03-example.txt'
#+END_SRC

#+RESULTS:

**** Solution
#+BEGIN_SRC j :results output scalar value :tangle src/day03.ijs
assert 2595824 = part1 in=. getin 'inputs/day-03.txt'
#+END_SRC

#+RESULTS:

*** Part 2: Approach 1
**** Function definitions

***** Filter rows

#+BEGIN_SRC j :results output silent :tangle src/day03.ijs
NB. Filter rows in y with 'u' common elements in column x
NB. y = input matrix
NB. x = target column for 'u'
NB. u = comparison operator (< , > , >: , <: , =)
filtrows=: 1 : '[ #~ {"1~ = -:@#@[ u +/@:({"1~)'
#+END_SRC

#+BEGIN_SRC j :results output value :exports results
y=. #.inv (?.10#247)
(".&.> ,:~ ]) ('y'; 'y <: filtrows 0'; 'y > filtrows 0'; 'y <: filtrows 5')
#+END_SRC

#+RESULTS:
#+begin_example
┌───────────────┬───────────────┬───────────────┬───────────────┐
│y              │y <: filtrows 0│y > filtrows 0 │y <: filtrows 5│
├───────────────┼───────────────┼───────────────┼───────────────┤
│1 1 0 1 1 1 0 0│1 1 0 1 1 1 0 0│0 1 0 0 1 0 1 0│1 1 0 1 1 1 0 0│
│0 1 0 0 1 0 1 0│1 0 1 0 0 1 0 1│0 0 0 0 0 0 1 1│1 0 1 0 0 1 0 1│
│0 0 0 0 0 0 1 1│1 1 1 0 0 1 1 1│0 1 0 1 1 1 1 1│1 1 1 0 0 1 1 1│
│1 0 1 0 0 1 0 1│1 0 0 1 1 1 0 1│0 1 0 1 1 1 1 0│0 1 0 1 1 1 1 1│
│1 1 1 0 0 1 1 1│1 1 1 0 0 1 0 0│0 0 1 0 0 1 1 1│1 0 0 1 1 1 0 1│
│0 1 0 1 1 1 1 1│               │               │1 1 1 0 0 1 0 0│
│1 0 0 1 1 1 0 1│               │               │0 1 0 1 1 1 1 0│
│1 1 1 0 0 1 0 0│               │               │0 0 1 0 0 1 1 1│
│0 1 0 1 1 1 1 0│               │               │               │
│0 0 1 0 0 1 1 1│               │               │               │
└───────────────┴───────────────┴───────────────┴───────────────┘
#+end_example

***** ❖ Reducer

#+BEGIN_SRC j :results output silent :tangle src/day03.ijs
NB. Reduce using verb 'u/\.' on a boxed list y
foldr=: 1 : '[: u&.>/\. ,&boxxopen'
#+END_SRC

***** Rating

#+BEGIN_SRC j :results output silent :tangle src/day03.ijs
NB. Recursively filter rows using 'u' common elements from each column
rating=: 1 : '[: >@(] #~ 1: = #&>) (] (u filtrows)~ foldr~ ;/@i.@-@{:@$)'
#+END_SRC

Reading from right to left, =rating= works as follows,

+ =] (u filtrows)~ foldr~ ;/@i.@-@{:@$=: Recursively filter rows with =u= common elements from each column
  - =;/@i.@-@{:@$=: Boxed sequence of integers in decreasing order from column length to 0
+ =>@(] #~ 1: = #&>)=: Unbox (first) element containing only one row.

***** Life support rating

#+BEGIN_SRC j :results output silent :tangle src/day03.ijs
part2=: */@:#.@(> rating ,: <: rating)
#+END_SRC

**** Test

#+BEGIN_SRC j :results output value :tangle src/day03.ijs
assert 230 = part2 inx=. getin 'inputs/day-03-example.txt'
#+END_SRC

#+RESULTS:

**** Solution
#+BEGIN_SRC j :results output scalar value :tangle src/day03.ijs
assert 2135254 = part2 in=. getin 'inputs/day-03.txt'
#+END_SRC

#+RESULTS:

*** Part 2: Approach 2
**** Function definitions

Approach is to iteratively remove all rows with the most (or least) common elements across each column.

#+BEGIN_SRC j :results output silent :tangle src/day03.ijs
rating=: 1 : 0
ix=. {.@I.@(-. @ (-: 1&|.)"1 @ |:) NB. index of first column where elements differ
cm=. { +/ u~ # - +/ 	     NB. common elements 'u' in x = column of y = data
fr=. ix (] #~ cm = {"1) ]  NB. filter all rows with 'cm' common elements in column (ix y)
fr`]@.(1 = #@])^:_ y	     NB. iterate until one row remains
)
#+END_SRC

#+BEGIN_SRC j :results output silent :tangle src/day03.ijs
part2=: [: */ [: #. > rating , <: rating
#+END_SRC

**** Test
#+BEGIN_SRC j :results output value :tangle src/day03.ijs
assert 230 = part2 inx=. getin 'inputs/day-03-example.txt'
#+END_SRC

#+RESULTS:
**** Solution
#+BEGIN_SRC j :results output scalar value :tangle src/day03.ijs
assert 2135254 = part2 in=. getin 'inputs/day-03.txt'
#+END_SRC

#+RESULTS:

** [[https://adventofcode.com/2021/day/4][Day 04: Giant Squid]]

#+TOC: headlines 2 local

*** Setup
   
#+BEGIN_SRC j :results output silent
cocurrent <'day04'
#+END_SRC

#+BEGIN_SRC j :results output silent :tangle src/day04.ijs
load <'utils.ijs'  NB. readin
#+END_SRC

*** Read data

#+BEGIN_SRC j :results output silent :tangle src/day04.ijs
getin=: a: -.~ <@". readin@]
#+END_SRC

Split list of calls and boards in input data,

#+BEGIN_SRC j :results output silent :tangle src/day04.ijs
calls=: 0&{::
boards=: _5 [\ >@}. 
#+END_SRC

*** General function definitions 
**** Winning Sequence

One approach to obtaining the winning sequence of boards and corresponding calls is described below.

Consider the following set of calls,

#+BEGIN_SRC j :results output value
excalls=: 45 41 47 36 46 27 44 24 33 35 26 38 43 28 23 32 34 25 29 39 31 40 37 42 30
#+END_SRC

#+RESULTS:

and the corresponding board,

#+BEGIN_SRC j :results output value :exports both
exboard=: _5 [\ 23 + 25?.25
exboard
#+END_SRC

#+RESULTS:
: 42 44 31 26 32
: 36 34 40 45 43
: 28 24 25 41 46
: 30 35 29 47 33
: 39 23 37 38 27

The call number (index) at which an element on the board is marked is,

#+BEGIN_SRC j :results output value :exports both
excalls i. exboard
#+END_SRC

#+RESULTS:
: 23  6 20 10 15
:  3 16 21  0 12
: 13  7 17  1  4
: 24  9 18  2  8
: 19 14 22 11  5

#+begin_important
The *maximum* in each row (or column) above is the call index at which all numbers in that row (or column) are marked.
#+end_important

For example, all numbers in the first row are not marked until the 23^rd number is called. For the second row, it is the 21^st number called and so on.
Thus,

#+BEGIN_SRC j :results output value :exports both
excalls ((>./"1 , >./)@i.) exboard
#+END_SRC

#+RESULTS:
: 23 21 17 24 22 24 16 22 11 15

#+begin_important
The earliest a board can win /Bingo!/ is given by the *minimum* of the (maximum row and column) indices. 
#+end_important

In the example above, the board wins after the 11^th number is called because after that all numbers in the 4^th column will be marked,

#+BEGIN_SRC j :results output value :exports both
excalls ((<./)@(>./"1 , >./)@i.) exboard
#+END_SRC

#+RESULTS:
: 11

Now consider the example set of calls and the three boards in the problem,
#+BEGIN_SRC j :results output silent
inx=: getin 'inputs/day-04-example.txt'
#+END_SRC

#+BEGIN_SRC j :results output value :exports both
calls inx
#+END_SRC
#+RESULTS:
: 7 4 9 5 11 17 23 2 0 14 21 24 10 16 13 6 15 25 12 22 18 20 8 19 3 26 1

#+BEGIN_SRC j :results output value :exports both
boards inx
#+END_SRC

#+RESULTS:
#+begin_example
22 13 17 11  0
 8  2 23  4 24
21  9 14 16  7
 6 10  3 18  5
 1 12 20 15 19

 3 15  0  2 22
 9 18 13 17  5
19  8  7 25 23
20 11 10 24  4
14 21 16 12  6

14 21 17 24  4
10 16 15  9 19
18  8 23 26 20
22 11 13  6  5
 2  0 12  3  7
#+end_example

The call indices at which each board wins /Bingo!/ ⇒ 1 row or column is completely marked,

#+BEGIN_SRC j :results output value :exports both
(calls (<./)@(>./"1 , >./)"_1@i. boards) inx
#+END_SRC

#+RESULTS:
: 13 14 11

Calls up to the n^th index = =(n + 1) {. calls= ⇒ above results must be incremented by one,

#+BEGIN_SRC j :results output value :exports both
(calls >:@(<./)@(>./"1 , >./)"_1@i. boards) inx
#+END_SRC

#+RESULTS:
: 14 15 12

#+begin_attention
*Grading-up* the winning call indices gives the corresponding boards.
#+end_attention

So a two column list of boards and corresponding win call indices, ordered by the call indices, is

#+BEGIN_SRC j :results output value :exports both
(calls (/: ,. /:~)@(>:@(<./)@(>./"1 , >./)"_1@i.) boards) inx
#+END_SRC

#+RESULTS:
: 2 12
: 0 14
: 1 15

 ⇒ the 2^nd board wins after the 12^th call, the 0^th board after the 14^th and the 1^st board after the 15^th call.

The winning sequence function is thus defined,

#+BEGIN_SRC j :results output silent :tangle src/day04.ijs
winseq=: (/: ,. /:~)@(>:@(<./)@(>./"1 , >./)"_1@i.)
#+END_SRC

**** Score

#+BEGIN_SRC j :results output silent :tangle src/day04.ijs
NB. Calculate score
NB. y = boards
NB. x = calls
NB. u = monadic function to select nth winning board
score=: 1 : '(c {:@{. x) * +/ (, b { y) -. (c {. x) [ ''b c''=. x u @ winseq y'
#+END_SRC

*** Part 1

**** Function definition

#+BEGIN_SRC j :results output silent :tangle src/day04.ijs
part1=: calls {. score boards
#+END_SRC

**** Test

#+BEGIN_SRC j :results output value :tangle src/day04.ijs
assert 4512 = part1 inx=. getin 'inputs/day-04-example.txt'
#+END_SRC

#+RESULTS:

**** Solution

#+BEGIN_SRC j :results output value :tangle src/day04.ijs
assert 2496 = part1 in=. getin 'inputs/day-04.txt'
#+END_SRC

#+RESULTS:

*** Part 2

**** Function definition

#+BEGIN_SRC j :results output silent :tangle src/day04.ijs
part2=: calls {: score boards
#+END_SRC

**** Test

#+BEGIN_SRC j :results output value :tangle src/day04.ijs
assert 1924 = part2 inx=. getin 'inputs/day-04-example.txt'
#+END_SRC

#+RESULTS:

**** Solution

#+BEGIN_SRC j :results output value :tangle src/day04.ijs
assert 25925 = part2 in=. getin 'inputs/day-04.txt'
#+END_SRC

#+RESULTS:
** [[https://adventofcode.com/2021/day/5][Day 05: Hydrothermal Venture]]

#+TOC: headlines 2 local

*** Setup

#+BEGIN_SRC j :results output silent
cocurrent <'day05'
#+END_SRC

#+BEGIN_SRC j :results output silent :tangle src/day05.ijs
load <'utils.ijs'  NB. readin
#+END_SRC

*** Read data

#+BEGIN_SRC j :results output silent :tangle src/day05.ijs
getin=: ".@(rplc&('->';',:';',';' ')) readin
#+END_SRC

Note that '->' is replaced with ',:' so that executing each row casts the =(x, y)= coordinates in each row to a $2 \times 2$ matrix. This results in 
an $N \times 2 \times 2$ matrix for $N$ points (rows) in the file.

*** General function definitions

**** ❖ Sequence generator

Generate sequence in closed interval =(x, y)=,

#+BEGIN_SRC j :results output silent :tangle src/day05.ijs 
NB. Generate sequence in closed interval (x, y)
NB. x < y: Ascending  ]  5 seq 8  => 5 6 7 8
NB. x > y: Descending ] _2 seq _5 => _2 _3 _4 _5
NB. x = y: Constant   ]  0 seq 0  => 0
seq=: [ + (-@* * i.@>:@|)@-
#+END_SRC

#+BEGIN_SRC j :results output value :exports results
(".&.> ,:~ ]) ('_3 seq 4'; '7 seq 3'; '9 seq 9')
#+END_SRC

#+RESULTS:
: ┌──────────────────┬─────────┬───────┐
: │_3 seq 4          │7 seq 3  │9 seq 9│
: ├──────────────────┼─────────┼───────┤
: │_3 _2 _1 0 1 2 3 4│7 6 5 4 3│9      │
: └──────────────────┴─────────┴───────┘

For 2-element =x = (x1, y1)= and =y = (x2, y2)=, =seq= can be considered to interpolate between the coordinates. 
Of course this only works for horizontal, vertical and 45^o diagonal lines!

#+BEGIN_SRC j :results output value :exports results
(".&.> ,:~ ]) ('(0 9) seq (5 9)'; '(3 2) seq (3 7)'; '(4 4) seq (8 8)')
#+END_SRC

#+RESULTS:
: ┌───────────────┬───────────────┬───────────────┐
: │(0 9) seq (5 9)│(3 2) seq (3 7)│(4 4) seq (8 8)│
: ├───────────────┼───────────────┼───────────────┤
: │0 1 2 3 4 5    │3 3 3 3 3 3    │4 5 6 7 8      │
: │9 9 9 9 9 9    │2 3 4 5 6 7    │4 5 6 7 8      │
: └───────────────┴───────────────┴───────────────┘

**** ❖ Points

#+BEGIN_SRC j :results output silent :tangle src/day05.ijs
NB. Interpolate points across coordinate endpoints
NB. y = N x 2 x 2 matrix of N points
NB.         2 x 2 submatrices are (x1 y1 ,: x2 y2) coordinates for each point
NB. Returns 2-column list of interpolated (x, y) pairs for all points
pts=: [: ; _2 <@|:@seq"1/\"_1 ]
#+END_SRC


#+BEGIN_SRC j :results output value :exports results
3 : 0''
y=. _2 [\"_1 (0 9 5 9 , 3 2 3 7 ,: 4 4 8 8)
g=. (".&.> ,:~ ]) ('y'; 'pts y')
smoutput g
)
#+END_SRC

#+RESULTS:
#+begin_example
┌───┬─────┐
│y  │pts y│
├───┼─────┤
│0 9│0 9  │
│5 9│1 9  │
│   │2 9  │
│3 2│3 9  │
│3 7│4 9  │
│   │5 9  │
│4 4│3 2  │
│8 8│3 3  │
│   │3 4  │
│   │3 5  │
│   │3 6  │
│   │3 7  │
│   │4 4  │
│   │5 5  │
│   │6 6  │
│   │7 7  │
│   │8 8  │
└───┴─────┘
#+end_example

**** Intersections

#+BEGIN_SRC j :results output silent :tangle src/day05.ijs
NB. Count number of intersections between N lines
NB. y = N x 2 x 2 matrix of N points
NB.         2 x 2 submatrices are (x1 y1 ,: x2 y2) coordinates for each point
NB. x is minimum number of intersections
intersect=: [: +/ [ <: [: #/.~ pts 
#+END_SRC

**** Filter vertical and horizontal lines

#+BEGIN_SRC j :results output silent :tangle src/day05.ijs
NB. Filter coordinates of vertical and horizontal lines
NB. y = N x 2 x 2 matrix of N points
NB.         2 x 2 submatrices are (x1 y1 ,: x2 y2) coordinates for each point
filtvh=: ] #~ (+./"1 @: =/)"_1
#+END_SRC

*** Part 1

**** Function definition

#+BEGIN_SRC j :results output silent :tangle src/day05.ijs
part1=: 2&intersect @ filtvh
#+END_SRC

**** Test

#+BEGIN_SRC j :results output value :tangle src/day05.ijs
assert 5 = part1 inx=. getin 'inputs/day-05-example.txt'
#+END_SRC

#+RESULTS:

**** Solution

#+BEGIN_SRC j :results output value :tangle src/day05.ijs
assert 7473 = part1 in=. getin 'inputs/day-05.txt'
#+END_SRC

#+RESULTS:

*** Part 2

**** Function definition

#+BEGIN_SRC j :results output silent :tangle src/day05.ijs
part2=: 2&intersect
#+END_SRC

**** Test

#+BEGIN_SRC j :results output value :tangle src/day05.ijs
assert 12 = part2 inx=. getin 'inputs/day-05-example.txt'
#+END_SRC

#+RESULTS:

**** Solution

#+BEGIN_SRC j :results output value :tangle src/day05.ijs
assert 24164 = part2 in=. getin 'inputs/day-05.txt'
#+END_SRC

#+RESULTS:

** [[https://adventofcode.com/2021/day/6][Day 06: Lanternfish]]

#+TOC: headlines 2 local

*** Setup

#+BEGIN_SRC j :results output silent
cocurrent <'day06'
#+END_SRC

#+BEGIN_SRC j :results output silent :tangle src/day06.ijs
load <'utils.ijs'  NB. readin
#+END_SRC

*** Read data

#+BEGIN_SRC j :results output silent :tangle src/day06.ijs
getin=: [: , ". readin
#+END_SRC

*** General function definitions

**** Stochastic matrix

This class of problems is most easily solved using a [[https://en.wikipedia.org/wiki/Stochastic_matrix][stochastic matrix]]. The function below defines a stochastic matrix per conditions of the problem,

#+BEGIN_SRC j :results output silent :tangle src/day06.ijs 
NB. stochastic matrix
stoctrix=: (1 0) ,~ (0 0 0 0 0 0 1 0) ,. (e.@i. 8)
#+END_SRC

#+BEGIN_SRC j :results output value :exports both
stoctrix
#+END_SRC

#+RESULTS:
: 0 1 0 0 0 0 0 0 0
: 0 0 1 0 0 0 0 0 0
: 0 0 0 1 0 0 0 0 0
: 0 0 0 0 1 0 0 0 0
: 0 0 0 0 0 1 0 0 0
: 0 0 0 0 0 0 1 0 0
: 1 0 0 0 0 0 0 1 0
: 0 0 0 0 0 0 0 0 1
: 1 0 0 0 0 0 0 0 0

**** Matrix operations

#+BEGIN_SRC j :results output silent :tangle src/day06.ijs
NB. Matrix product
mp=: +/ . *
#+END_SRC

#+BEGIN_SRC j :results output silent :tangle src/day06.ijs
NB. Raise matrix to nth power
NB. Source: https://code.jsoftware.com/wiki/Essays/Repeated_Squaring
mpow=: 4 : 'mp/ mp~^:(I.|.#:y) x'
#+END_SRC

**** Number of fish

#+BEGIN_SRC j :results output silent :tangle src/day06.ijs
NB. Count number of fish after N generations
NB. x = input/start state
NB. y = generations (integer)
nfish=: [: +/ stoctrix&mpow@] mp ([: <:@#/.~ (i.9) , [)
#+END_SRC

Reading from right to left, =nfish= works as follows, 

+ =([: <:@#/.~ (i.9) , [)=: Count number of fish in input grouped by =x= (age)
+ =stoctrix&mpow@] mp=: Multiply grouped fish count by stochastic matrix after =y= generations
+ =+/=: Total fish after =y= generations

*** Part 1

**** Function definition

#+BEGIN_SRC j :results output silent :tangle src/day06.ijs
part1=: nfish&80
#+END_SRC

**** Test

#+BEGIN_SRC j :results output value :tangle src/day06.ijs
inx=. getin 'inputs/day-06-example.txt'
assert 26 = inx nfish 18 
assert 5934 = part1 inx
#+END_SRC

#+RESULTS:

**** Solution

#+BEGIN_SRC j :results output value :tangle src/day06.ijs
assert 360761 = part1 in=. getin 'inputs/day-06.txt'
#+END_SRC

#+RESULTS:

*** Part 2

**** Function definition

#+BEGIN_SRC j :results output silent :tangle src/day06.ijs
part2=: nfish&256
#+END_SRC

**** Test

#+BEGIN_SRC j :results output value :tangle src/day06.ijs
assert 26984457539 = part2 inx=. getin 'inputs/day-06-example.txt'
#+END_SRC

#+RESULTS:

**** Solution

#+BEGIN_SRC j :results output value :tangle src/day06.ijs
assert 1632779838045 = part2 in=. getin 'inputs/day-06.txt'
#+END_SRC

#+RESULTS:

** [[https://adventofcode.com/2021/day/7][Day 07: The Treachery of Whales]]

#+TOC: headlines 2 local

*** Setup

#+BEGIN_SRC j :results output silent
cocurrent <'day07'
#+END_SRC

#+BEGIN_SRC j :results output silent :tangle src/day07.ijs
load 'stats/base'
load <'utils.ijs'  NB. readin
#+END_SRC

*** Read data

#+BEGIN_SRC j :results output silent :tangle src/day07.ijs
getin=: [: , ". readin
#+END_SRC

*** Part 1

**** Function definition

See this [[https://math.stackexchange.com/questions/318381/on-a-1-d-line-the-point-that-minimizes-the-sum-of-the-distances-is-the-median][stackexchange]] question for the explanation of why median minimizes the distance on a 1-D line. 

#+BEGIN_SRC j :results output silent :tangle src/day07.ijs
part1=: [: +/ |@(] - median)
#+END_SRC

**** Test

#+BEGIN_SRC j :results output value :tangle src/day07.ijs
assert 37 = part1 inx=. getin 'inputs/day-07-example.txt'
#+END_SRC

#+RESULTS:

**** Solution

#+BEGIN_SRC j :results output value :tangle src/day07.ijs
assert 329389 = part1 in=. getin 'inputs/day-07.txt'
#+END_SRC

#+RESULTS:

*** Part 2

**** Function definition

#+BEGIN_SRC j :results output silent :tangle src/day07.ijs
part2=: [: x:@+/ -:@(>: * ])@(] |@- <.@mean)
#+END_SRC

Reading from right to left, this works as follows,

+ =-:@(>: * ])@(] |@- <.@mean)=
  - =(] |@- <.@mean)=: Mean absolute deviation = distance from best horizontal position
    - =<.@mean=: Largest integer not tolerantly exceeding the mean
  - =-:@(>: * ])=: Fuel cost for each crab = $n (n + 1)/2$
+ =+/=: Total fuel cost
+ =x:=: Extended integer (full precision)

**** Test

#+BEGIN_SRC j :results output value :tangle src/day07.ijs
assert 170 = part2 inx=. getin 'inputs/day-07-example.txt'
#+END_SRC

#+RESULTS:

***** Notes                                                        :noexport:

    The solution in the example is =168=. This is obtained by using =>.@mean=, instead of =<.@mean=, in =part2= above. The reason is that the mean 
    optimizes $n^2$ but here it is used to optimize $n (n+1) / 2 = \mathcal{O} (n^2 + n)$. The uncertainty therefore comes from the residual 
    $\mathcal{O}(n)$.

**** Solution

#+BEGIN_SRC j :results output value :tangle src/day07.ijs
assert 86397080 = part2 in=. getin 'inputs/day-07.txt'
#+END_SRC

#+RESULTS:

** [[https://adventofcode.com/2021/day/8][Day 08: Seven Segment Search]]

#+TOC: headlines 2 local

*** Setup

#+BEGIN_SRC j :results output silent
cocurrent <'day08'
#+END_SRC

#+BEGIN_SRC j :results output silent :tangle src/day08.ijs
load <'utils.ijs'  NB. readin
#+END_SRC

*** Read data

#+BEGIN_SRC j :results output silent :tangle src/day08.ijs
getin=: [: /:~&.> ;: readin
#+END_SRC

To simplify the solution, the random-ordered entries are sorted alphabetically. 

*** Part 1

**** Function definitions

This solution is from [[https://github.com/jitwit/aoc/blob/a/J/21/08.ijs][jitwit]].

#+BEGIN_SRC j :results output silent :tangle src/day08.ijs
NB. Count number of digits of given length
NB. y = boxed list of coded digits
NB. x = list of digit lengths
NB. output is count of digits of lengths x in y
ndiglen=: [: +/ [: , [ e.~ #&> @ ]
#+END_SRC

Reading from right to left, =ndiglen= works as follows,

+ =#&> @ ]=: Number of characters in each entry of =y=
+ =[ e.~=: Flag all entry-lengths in =x=
+ =[: +/ [: ,=: Flatten matrix and sum all elements


#+BEGIN_SRC j :results output silent :tangle src/day08.ijs
part1=: (2 3 4 7) ndiglen _4&{."1@]
#+END_SRC

**** Test

#+BEGIN_SRC j :results output value :tangle src/day08.ijs
assert 26 = part1 inx=. getin 'inputs/day-08-example.txt'
#+END_SRC

#+RESULTS:

**** Solution

#+BEGIN_SRC j :results output value :tangle src/day08.ijs
assert 284 = part1 in=. getin 'inputs/day-08.txt'
#+END_SRC

#+RESULTS:

*** Part 2

**** Unique identifiers

Based on logic from: https://github.com/jitwit/aoc/blob/a/J/21/08.ijs.

  #+BEGIN_SRC j :results output silent :tangle src/day08.ijs
NB. Table of unique identifiers
NB. A digit can be uniquely identified by length, 
NB. intersection with 1 and intersection with 4
tbluids=: _3 ]\ 6 2 3 2 2 2 5 1 2 5 2 3 4 2 4 5 1 3 6 1 3 3 2 2 7 2 4 6 2 4
  #+END_SRC

#+BEGIN_SRC j :results output value :exports results
tbluids
#+END_SRC

#+RESULTS:
#+begin_example
6 2 3
2 2 2
5 1 2
5 2 3
4 2 4
5 1 3
6 1 3
3 2 2
7 2 4
6 2 4
#+end_example

The first column is length. Second and third columns are intersections with 1 and 4.

**** Function definitions

***** Get identifiers

#+BEGIN_SRC j :results output silent :tangle src/day08.ijs
NB. Get identifiers of output x based on encodings in y
NB. y = boxed list of outputs
NB. x = boxed list of encoded entries (#y = 10)
getids=: ([: #&> ]) ,. ] +/@e.&>/ (0 2&{)@(/: #&>)@[
#+END_SRC

Reading from right to left, =getids= works as follows,

+ =] +/@e.&>/ (0 2&{)@(/: #&>)@[=: Get intersections of each output entry in =y= with 1 and 4 in encodings =x=
    - =(0 2&{)@(/: #&>)@[=: Sort encodings =y= by length and select digits 1 and 4
+ =([: #&> ]) ,.=: Prepend column with lengths of output entries
+ Result is a =(#y) x 3= matrix,
  - First column are the lengths of output entries
  - Second and third columns are intersections of corresponding outputs with 1 and 4

#+BEGIN_SRC j :results output value :exports results
3 : 0''
y=. {. getin 'inputs/day-08-example.txt'
g=. (".&.> ,.~ ]) ('e=. 10&{. y'; 'o=. _4&{. y')
smoutput g
)
#+END_SRC

#+RESULTS:
: ┌───────────┬────────────────────────────────────────────────────────────┐
: │e=. 10&{. y│┌──┬───────┬──────┬──────┬────┬─────┬──────┬─────┬─────┬───┐│
: │           ││be│abcdefg│bcdefg│acdefg│bceg│cdefg│abdefg│bcdef│abcdf│bde││
: │           │└──┴───────┴──────┴──────┴────┴─────┴──────┴─────┴─────┴───┘│
: ├───────────┼────────────────────────────────────────────────────────────┤
: │o=. _4&{. y│┌───────┬─────┬──────┬────┐                                 │
: │           ││abcdefg│bcdef│bcdefg│bceg│                                 │
: │           │└───────┴─────┴──────┴────┘                                 │
: └───────────┴────────────────────────────────────────────────────────────┘

#+BEGIN_SRC j :results output value :exports results
3 : 0''
y=. {. getin 'inputs/day-08-example.txt'
(".&.> ,.~ ]) ('e=. 10&{. y'; 'o=. _4&{. y')
g=. (".&.> ,.~ ]) ('s=. (/: #&>) e'; 'd=. (0 2&{) s'; 'i=. o +/@e.&>/ d'; '(#&> o) ,. i'; 'e getids o')
smoutput g
)
#+END_SRC

#+RESULTS:
#+begin_example
┌────────────────┬────────────────────────────────────────────────────────────┐
│s=. (/: #&>) e  │┌──┬───┬────┬─────┬─────┬─────┬──────┬──────┬──────┬───────┐│
│                ││be│bde│bceg│cdefg│bcdef│abcdf│bcdefg│acdefg│abdefg│abcdefg││
│                │└──┴───┴────┴─────┴─────┴─────┴──────┴──────┴──────┴───────┘│
├────────────────┼────────────────────────────────────────────────────────────┤
│d=. (0 2&{) s   │┌──┬────┐                                                   │
│                ││be│bceg│                                                   │
│                │└──┴────┘                                                   │
├────────────────┼────────────────────────────────────────────────────────────┤
│i=. o +/@e.&>/ d│2 4                                                         │
│                │2 3                                                         │
│                │2 4                                                         │
│                │2 4                                                         │
├────────────────┼────────────────────────────────────────────────────────────┤
│(#&> o) ,. i    │7 2 4                                                       │
│                │5 2 3                                                       │
│                │6 2 4                                                       │
│                │4 2 4                                                       │
├────────────────┼────────────────────────────────────────────────────────────┤
│e getids o      │7 2 4                                                       │
│                │5 2 3                                                       │
│                │6 2 4                                                       │
│                │4 2 4                                                       │
└────────────────┴────────────────────────────────────────────────────────────┘
#+end_example

***** Decode

#+BEGIN_SRC j :results output silent :tangle src/day08.ijs
NB. Return decimal number of output in y
NB. y = encodings (first 10 columns) and outputs to decode (last four columns)
NB. x = lookup table with unique identifiers for digits
decode=: 10 #. [ i. (10&{. getids _4&{.)@]
#+END_SRC

Reading from right to left, =decode= works as follows,

+ =[ i. (10&{. getids _4&{.)@]=: Find digits in output of =y= in =x= (table of identifiers)
    - =(10&{. getids _4&{.)@]=: Get identifiers for digits in output of =y= (last four columns) using encodings in =y= (first 10 columns)
+ =10 #.=: Convert individual digits to decimal number

***** Total

#+BEGIN_SRC j :results output silent :tangle src/day08.ijs
part2=: [: +/ (tbluids decode ])"1
 #+END_SRC

**** Test

#+BEGIN_SRC j :results output value :tangle src/day08.ijs
assert 61229 = part2 inx=. getin 'inputs/day-08-example.txt'
#+END_SRC

#+RESULTS:

**** Solution

#+BEGIN_SRC j :results output value :tangle src/day08.ijs
assert 973499 = part2 in=. getin 'inputs/day-08.txt'
#+END_SRC

#+RESULTS:

** [[https://adventofcode.com/2021/day/9][Day 09: Smoke Basin]]

#+TOC: headlines 2 local

*** Setup

#+BEGIN_SRC j :results output silent
cocurrent <'day09'
#+END_SRC

#+BEGIN_SRC j :results output silent :tangle src/day09.ijs
load <'utils.ijs'  NB. readin
#+END_SRC

*** Read data

#+BEGIN_SRC j :results output silent :tangle src/day09.ijs
getin=: "."0 readin
#+END_SRC

*** Part 1

**** Function definitions

This solution follows the approach in [[https://www.jsoftware.com/help/learning/31.htm][Golden Rule Example 2: Conway's "Life"]],

***** Low points

#+BEGIN_SRC j :results output silent :tangle src/day09.ijs
NB. Find low points in matrix y
NB. Low points = locations that are lower than any of 
NB. its adjacent (up, down, left, and right) locations
lowpoints=: ] < [: <./ (_1&* , ])@=@i.@2: (|.!.9) ]
#+END_SRC

#+BEGIN_SRC j :results output value :exports results
3 : 0''
y=. getin 'inputs/day-09-example.txt'
g=. (".&.> ,:~ ]) ('y'; 'lowpoints y')
smoutput g
)
#+END_SRC

#+RESULTS:
: ┌───────────────────┬───────────────────┐
: │y                  │lowpoints y        │
: ├───────────────────┼───────────────────┤
: │2 1 9 9 9 4 3 2 1 0│0 1 0 0 0 0 0 0 0 1│
: │3 9 8 7 8 9 4 9 2 1│0 0 0 0 0 0 0 0 0 0│
: │9 8 5 6 7 8 9 8 9 2│0 0 1 0 0 0 0 0 0 0│
: │8 7 6 7 8 9 6 7 8 9│0 0 0 0 0 0 0 0 0 0│
: │9 8 9 9 9 6 5 6 7 8│0 0 0 0 0 0 1 0 0 0│
: └───────────────────┴───────────────────┘

***** Risk level

#+BEGIN_SRC j :results output silent :tangle src/day09.ijs
part1=: [: +/ [: , >:@] * lowpoints
#+END_SRC

**** Test

#+BEGIN_SRC j :results output value :tangle src/day09.ijs
assert 15 = part1 inx=. getin 'inputs/day-09-example.txt'
#+END_SRC

#+RESULTS:

**** Solution

#+BEGIN_SRC j :results output value :tangle src/day09.ijs
assert 548 = part1 in=. getin 'inputs/day-09.txt'
#+END_SRC

#+RESULTS:

*** Part 2

**** Function definitions

***** Find adjacent regions

    The problem is greatly simplified by using =findadj= from the [[http://www.jsoftware.com/pipermail/general/2005-August/023886.html][Jforum]].

#+BEGIN_SRC j :results output silent :tangle src/day09.ijs
findadj=: (|."1@|:@:>. * * 1&(|.!.0))^:4^:_ @ (*>:@i.@$)
#+END_SRC

#+BEGIN_SRC j :results output value :exports results
3 : 0''
y=. 5 9$1 1 0 0 0 1 1 0 0 1 1 1 0 0 0 1 1 0 0 0 0 0 1 0 0 1 0 0 0 0 0 1 1 1 1
g=. (".&.> ,:~ ]) ('y'; 'findadj y')
smoutput g
)
#+END_SRC

#+RESULTS:
: ┌─────────────────┬─────────────────────────┐
: │y                │findadj y                │
: ├─────────────────┼─────────────────────────┤
: │1 1 0 0 0 1 1 0 0│12 12  0 0  0 45 45  0  0│
: │1 1 1 0 0 0 1 1 0│12 12 12 0  0  0 45 45  0│
: │0 0 0 0 1 0 0 1 0│ 0  0  0 0 45  0  0 45  0│
: │0 0 0 0 1 1 1 1 1│ 0  0  0 0 45 45 45 45 45│
: │1 0 0 0 1 1 0 0 1│37  0  0 0 45 45  0  0 45│
: └─────────────────┴─────────────────────────┘

***** Basin sizes

#+BEGIN_SRC j :results output silent :tangle src/day09.ijs
NB. Basin sizes in descending order
bsizes=: (\:~)@(#/.~)@(] #~ 0 ~: ]) ,@findadj@(9&~:)
#+END_SRC

Reading from right to left, =bsizes= works as follows,

+ =,@findadj@(9&~:)=:
    - =(9&~:)=: Flag all heights not equal to 9.
    - =findadj=: Mark adjacent regions with unique numbers.
    - =,=: Flatten matrix.
+ =(\:~)@(#/.~)@(] #~ 0 ~: ])=:
   - =(] #~ 0 ~: ])=: Remove 0's = region boundaries.
   - =(#/.~)=: Count number of points in each region.
   - =(\:~)=: Sort counts in descending order.

#+BEGIN_SRC j :results output value :exports results
3 : 0''
y=. 4 6 $ 2 9 0 8 9 1 6 9 5 7 9 4 4 9 3 5
g=. (".&.> ,.~ ]) ('y'; 'r =. (9&~:) y'; 't=. findadj r'; 's=. (] #~ 0 ~: ]) , t'; 'b=. #/.~ s'; '\:~ b'; 'bsizes y')
smoutput g
)
#+END_SRC

#+RESULTS:
#+begin_example
┌─────────────────────┬───────────────────────────────────────────────┐
│y                    │2 9 0 8 9 1                                    │
│                     │6 9 5 7 9 4                                    │
│                     │4 9 3 5 2 9                                    │
│                     │0 8 9 1 6 9                                    │
├─────────────────────┼───────────────────────────────────────────────┤
│r =. (9&~:) y        │1 0 1 1 0 1                                    │
│                     │1 0 1 1 0 1                                    │
│                     │1 0 1 1 1 0                                    │
│                     │1 1 0 1 1 0                                    │
├─────────────────────┼───────────────────────────────────────────────┤
│t=. findadj r        │20  0 23 23  0 12                              │
│                     │20  0 23 23  0 12                              │
│                     │20  0 23 23 23  0                              │
│                     │20 20  0 23 23  0                              │
├─────────────────────┼───────────────────────────────────────────────┤
│s=. (] #~ 0 ~: ]) , t│20 23 23 12 20 23 23 12 20 23 23 23 20 20 23 23│
├─────────────────────┼───────────────────────────────────────────────┤
│b=. #/.~ s           │5 9 2                                          │
├─────────────────────┼───────────────────────────────────────────────┤
│\:~ b                │9 5 2                                          │
├─────────────────────┼───────────────────────────────────────────────┤
│bsizes y             │9 5 2                                          │
└─────────────────────┴───────────────────────────────────────────────┘
#+end_example

***** Three largest basins

#+BEGIN_SRC j :results output silent :tangle src/day09.ijs
part2=: */ 3&{. bsizes
#+END_SRC

**** Test

#+BEGIN_SRC j :results output value :tangle src/day09.ijs
assert 1134 = part2 inx=. getin 'inputs/day-09-example.txt'
#+END_SRC

#+RESULTS:

**** Solution

#+BEGIN_SRC j :results output value :tangle src/day09.ijs
assert 786048 = part2 in=. getin 'inputs/day-09.txt'
#+END_SRC

#+RESULTS:

** [[https://adventofcode.com/2021/day/10][Day 10: Syntax Scoring]]

#+TOC: headlines 2 local

*** Setup

#+BEGIN_SRC j :results output silent
cocurrent <'day10'
#+END_SRC

#+BEGIN_SRC j :results output silent :tangle src/day10.ijs
load <'utils.ijs'  NB. readin
#+END_SRC

*** General function definitions

***** Pairs

#+BEGIN_SRC j :results output silent :tangle src/day10.ijs
pairs=: _2 [\ '()[]{}<>'
#+END_SRC

#+BEGIN_SRC j :results output value :exports results
pairs
#+END_SRC

#+RESULTS:
: ()
: []
: {}
: <>

***** ❖ Remove characters

#+BEGIN_SRC j :results output silent :tangle src/day10.ijs
NB. Replace characters with empty string
NB. y = input string
NB. x = boxed list of characters to remove
rmchars=: ] rplc [: , (<'') ,.~ [
#+END_SRC

Reading from right to left, =rmchars= works as follows,

+ =] rplc [: , (<'') ,.~ [=: Replace all characters of =x= in =y= with blank character ⇒ remove characters in =x= from =y=
    - =[: , (<'') ,.~ [=: Intersperse blank character =''= with =x=

#+BEGIN_SRC j :results output value :exports results
3 : 0''
y=. '{([(<{}[<>[]}>{[]{[(<()>'
r=. ('{}'; '['; '()'; '>')
b=. <''
g=. (".&.> ,.~ ]) ('y'; 'r'; 'b'; ', b ,.~ r '; 'y rplc , b ,.~ r';'r rmchars y')
smoutput g
)
#+END_SRC

#+RESULTS:

***** Filter corrupt or incomplete entries

#+BEGIN_SRC j :results output silent :tangle src/day10.ijs
NB. Filter corrupt or incomplete entries
NB. y = input with all pairs removed from each entry
NB. x = 0 (incomplete) and 1 (corrupt)
filterr=: ] #~ [ = [: +./"1 (({:"1 pairs) e. ])&>
#+END_SRC

Reading from right to left, =filterr= works as follows,

+ =[: +./"1 (({:"1 pairs) e. ])&>=: Flag all entries in boxed input =y= with any closed brackets (={:"1 pairs=). These are /corrupt/ entries.
+ =] #~ [ \==: Invert entries if =x = 0= (incomplete). Use resulting Boolean list to filter from =y=.

**** Read data

 #+BEGIN_SRC j :results output silent :tangle src/day10.ijs
 getin=: [: ((<"1 pairs) rmchars ])&.> < readin
 #+END_SRC

*** Part 1

**** Function definitions

***** Scores

#+BEGIN_SRC j :results output silent :tangle src/day10.ijs 
NB. Corrupt entry scores
corrscrs=:(')';'3';']';'57';'}';'1197';'>';'25137')
#+END_SRC

***** First illegal character

#+BEGIN_SRC j :results output silent :tangle src/day10.ijs
NB. Get first illegal (closing) character in entry
NB. y = boxed character list (superset or subset of pairs)
illchar=: [: {. (<"0 {."1 pairs) rmchars ]
#+END_SRC

***** Corrupt scores

#+BEGIN_SRC j :results output silent :tangle src/day10.ijs
NB. Array with error scores for corrupt entries
NB. y = boxed character list (superset or subset of pairs)
corrupt=: ".@(] rplc&corrscrs)@illchar
#+END_SRC

***** Total syntax error score

#+BEGIN_SRC j :results output silent :tangle src/day10.ijs
part1=: [: +/ [: corrupt&> (1: filterr ])
#+END_SRC

**** Test

#+BEGIN_SRC j :results output value :tangle src/day10.ijs
assert 26397 = part1 inx=. getin 'inputs/day-10-example.txt'
#+END_SRC

#+RESULTS:

**** Solution

#+BEGIN_SRC j :results output value :tangle src/day10.ijs
assert 370407 = part1 in=. getin 'inputs/day-10.txt'
#+END_SRC

#+RESULTS:

*** Part 2

**** Function definition

***** Scores

#+BEGIN_SRC j :results output silent :tangle src/day10.ijs 
NB. Incomplete entry scores
incmpscrs=:('(';'1';'[';'2';'{';'3';'<';'4')
#+END_SRC

***** Incomplete scores

#+BEGIN_SRC j :results output silent :tangle src/day10.ijs
NB. Array with scores for incomplete entries
incomplete=: ([: {. (+ 5&*)/\.)@:("."0)@(] rplc&incmpscrs)
#+END_SRC

***** Middle score

#+BEGIN_SRC j :results output silent :tangle src/day10.ijs
part2=: [: (<.@-:@# { /:~) [: incomplete&> (0: filterr ])
#+END_SRC

**** Test

#+BEGIN_SRC j :results output value :tangle src/day10.ijs
assert 288957 = part2 inx=. getin 'inputs/day-10-example.txt'
#+END_SRC

#+RESULTS:

**** Solution

#+BEGIN_SRC j :results output value :tangle src/day10.ijs
assert 3249889609 = part2 in=. getin 'inputs/day-10.txt'
#+END_SRC

#+RESULTS:

** [[https://adventofcode.com/2021/day/11][Day 11: Dumbo Octopus]]

#+TOC: headlines 2 local

*** Setup

#+BEGIN_SRC j :results output silent
cocurrent <'day11'
#+END_SRC

#+BEGIN_SRC j :results output silent :tangle src/day11.ijs
load <'utils.ijs'  NB. readin
#+END_SRC

*** Read data

#+BEGIN_SRC j :results output silent :tangle src/day11.ijs
getin=: "."0 readin
#+END_SRC

*** General function definition

***** Pad

#+BEGIN_SRC j :results output silent :tangle src/day11.ijs 
NB. Surround matrix y with constant x
NB. y = input matrix
NB. x = padding constant
pad=: [,.~ [,~ [,. ,
#+END_SRC


#+BEGIN_SRC j :results output value :exports results
(". ;~ ])&> ('i. 2 2'; '0 pad i.2 2'; 'i. 3 4'; '_4 pad i. 3 4')
#+END_SRC

#+RESULTS:
#+begin_example
┌─────────────┬─────────────────┐
│i. 2 2       │0 1              │
│             │2 3              │
├─────────────┼─────────────────┤
│0 pad i.2 2  │0 0 0 0          │
│             │0 0 1 0          │
│             │0 2 3 0          │
│             │0 0 0 0          │
├─────────────┼─────────────────┤
│i. 3 4       │0 1  2  3        │
│             │4 5  6  7        │
│             │8 9 10 11        │
├─────────────┼─────────────────┤
│_4 pad i. 3 4│_4 _4 _4 _4 _4 _4│
│             │_4  0  1  2  3 _4│
│             │_4  4  5  6  7 _4│
│             │_4  8  9 10 11 _4│
│             │_4 _4 _4 _4 _4 _4│
└─────────────┴─────────────────┘
#+end_example

***** Flash

Per conditions of the problem,

- Any octopus with an energy level greater than 9 flashes. This increases the energy level of all adjacent octopuses by 1, including octopuses that are diagonally adjacent. If this causes an octopus to have an energy level greater than 9, it also flashes. This process continues as long as new octopuses keep having their energy level increased beyond 9. (An octopus can only flash at most once per step.)
- Finally, any octopus that flashed during this step has its energy level set to 0, as it used all of its energy to flash.

#+BEGIN_SRC j :results output silent :tangle src/day11.ijs
flash=: ((9&>:) *. (0&<)) * ((1 1 ,: 3 3) (+/@,);._3 (0&pad)@(9&<)) + ]
#+END_SRC

Reading from right to left, =flash= works as follows,

+ =+ ]=: Add the left expression to the input matrix
+ =((9&>:) *. (0&<)) * ((1 1 ,: 3 3) (+/@,);._3 (0&pad)@(9&<)=:
    - =(0&pad)@(9&<)=: Flag all energy levels less than 9 and pad resulting Boolean matrix with zeros.
    - =((1 1 ,: 3 3) (+/@,);._3 (0&pad)@(9&<)=: For a =3 x 3= tile size, with horizontal and vertical displacement of =1 x 1=, sum all elements in each tile.
    - =((9&>:) *. (0&<))=: Set all energy levels that flashed to 0.
     
***** Step

#+BEGIN_SRC j :results otuput silent :tangle src/day11.ijs
NB. Increase the energy level and flash until no energy levels are greater than 9
step=: flash^:_ @: >:
#+END_SRC

*** Part 1

**** Function definition

#+BEGIN_SRC j :results output silent :tangle src/day11.ijs
NB. y = input
NB. x = number of steps
part1=: 4 : '(+/)@(0&=)@, step^:(i.x) y'
#+END_SRC


**** Test

#+BEGIN_SRC j :results output value :tangle src/day11.ijs
inx=: getin 'inputs/day-11-example.txt'
assert 204 = 11 part1 inx
assert 1656 = 101 part1 inx
#+END_SRC

#+RESULTS:

**** Solution

#+BEGIN_SRC j :results output value :tangle src/day11.ijs
assert 1594 = 101 part1 in=. getin 'inputs/day-11.txt'
#+END_SRC

#+RESULTS:

*** Part 2

**** Function definitions

***** ❖ All equal

#+BEGIN_SRC j :results output silent :tangle src/day11.ijs
NB. Returns 1 if all elements are equal
NB. y = input (infinite rank)
alleq=: 1&=@#@~.@,
#+END_SRC

***** Synchronization step

#+BEGIN_SRC j :results output silent :tangle src/day11.ijs
part2=: [: <:@# [: step^:(-.@alleq)^:(<_) ]
#+END_SRC

**** Test

#+BEGIN_SRC j :results output value :tangle src/day11.ijs
assert 195 = part2 inx=. getin 'inputs/day-11-example.txt'
#+END_SRC

#+RESULTS:

**** Solution

#+BEGIN_SRC j :results output value :tangle src/day11.ijs
assert 437 = part2 in=. getin 'inputs/day-11.txt'
#+END_SRC

#+RESULTS:

** [[https://adventofcode.com/2021/day/12][Day 12: Passage Pathing]]

#+TOC: headlines 2 local

*** Setup

#+BEGIN_SRC j :results output silent
cocurrent <'day12'
#+END_SRC

#+BEGIN_SRC j :results output silent :tangle src/day12.ijs
load <'utils.ijs'  NB. readin
#+END_SRC

*** Read data

#+BEGIN_SRC j :results output silent :tangle src/day12.ijs
getin=: [: (] , |."1) [: ({. , {:)"1 [: ;: readin ]
#+END_SRC

Reading from right to left, =getin= works as follows,

+ =;: readin ]=: Read file and partition strings into boxed words
+ =({. , {:)"1=: Extract the first and third columns (vertices)
+ =(] , |."1)=: Append the reversed list to itself ⇒ all connections in the undirected graph
 
*** General function definitions

***** Connections to vertex

#+BEGIN_SRC j :results output silent :tangle src/day12.ijs 
NB. Connections to a given vertex x in graph y
connects=: ({:"1)@] #~ ] (E. {."1)~ [
#+END_SRC

#+BEGIN_SRC j :results output value :exports results
y=. _2 [\ ('start'; 'A'; 'A'; 'b'; 'A'; 'end'; 'b'; 'end'; 'A'; 'start'; 'b'; 'start'; 'end'; 'A'; 'end'; 'b'; 'b'; 'A')
(".&.> ,:~ ]) ('y'; '(<''A'') connects y'; '(<''b'') connects y')
#+END_SRC

#+RESULTS:
#+begin_example
┌─────────────┬─────────────────┬─────────────────┐
│y            │(<'A') connects y│(<'b') connects y│
├─────────────┼─────────────────┼─────────────────┤
│┌─────┬─────┐│┌─┬───┬─────┐    │┌───┬─────┬─┐    │
││start│A    │││b│end│start│    ││end│start│A│    │
│├─────┼─────┤│└─┴───┴─────┘    │└───┴─────┴─┘    │
││A    │b    ││                 │                 │
│├─────┼─────┤│                 │                 │
││A    │end  ││                 │                 │
│├─────┼─────┤│                 │                 │
││b    │end  ││                 │                 │
│├─────┼─────┤│                 │                 │
││A    │start││                 │                 │
│├─────┼─────┤│                 │                 │
││b    │start││                 │                 │
│├─────┼─────┤│                 │                 │
││end  │A    ││                 │                 │
│├─────┼─────┤│                 │                 │
││end  │b    ││                 │                 │
│├─────┼─────┤│                 │                 │
││b    │A    ││                 │                 │
│└─────┴─────┘│                 │                 │
└─────────────┴─────────────────┴─────────────────┘
#+end_example

***** Lower case characters

#+BEGIN_SRC j :results output silent :tangle src/day12.ijs
NB. Flag all lower case characters in y
issmall=: (a. {~ 97 + i.26) e.~ ]
#+END_SRC

#+BEGIN_SRC j :results output value :exports results
issmall &.> ('a';'A';'bc';'D';'o';'*'; 'start'; 'fg'; 'NX')
#+END_SRC

#+RESULTS:
: ┌─┬─┬───┬─┬─┬─┬─────────┬───┬───┐
: │1│0│1 1│0│1│0│1 1 1 1 1│1 1│0 0│
: └─┴─┴───┴─┴─┴─┴─────────┴───┴───┘

***** Filter small caves

#+BEGIN_SRC j :results output silent :tangle src/day12.ijs
NB. Filter small caves from graph y
filtsm=: (] #~ ((+./)@:issmall)&>)@:~.@:(('start';'end') -.~ ])@:,
#+END_SRC

***** Count paths

#+BEGIN_SRC j :results output silent :tangle src/day12.ijs
NB. Count paths from x to y in a graph satisfying condition u
dfs=: 1 : 0
(a: u dfs y)
:
cave=. y
seen=. x
if. cave = (<'end') do. 1 return. end.
if. (cave e. seen) do.
  if. (cave = (<'start')) do. 0 return. end.
  if. (cave u (seen (e. # [) smcaves)) do. 0 return. end.
end.
+/ ((seen , cave) u dfs ])"1 0 (y connects graph)
)
#+END_SRC

*** Part 1

**** Function definition

#+BEGIN_SRC j :results output silent :tangle src/day12.ijs
part1=: 3 : 'e. dfs (<''start'') [ smcaves=: filtsm graph=: y'
#+END_SRC

**** Test

#+BEGIN_SRC j :results output value :tangle src/day12.ijs
assert 10  = part1 inx=. getin 'inputs/day-12-example-1.txt'
assert 19  = part1 inx=. getin 'inputs/day-12-example-2.txt'
assert 226 = part1 inx=. getin 'inputs/day-12-example-3.txt'
#+END_SRC

#+RESULTS:

**** Solution

#+BEGIN_SRC j :results output value :tangle src/day12.ijs
assert 4304 = part1 in=. getin 'inputs/day-12.txt'
#+END_SRC

#+RESULTS:

*** Part 2

**** Function definition

#+BEGIN_SRC j :results output silent :tangle src/day12.ijs
part2=: 3 : '((<:@:# > +/)@:~:@:,) dfs (<''start'') [ smcaves=: filtsm graph=: y'
#+END_SRC

**** Test

#+BEGIN_SRC j :results output value :tangle src/day12.ijs
assert 36   = part2 inx=. getin 'inputs/day-12-example-1.txt'
assert 103  = part2 inx=. getin 'inputs/day-12-example-2.txt'
assert 3509 = part2 inx=. getin 'inputs/day-12-example-3.txt'
#+END_SRC

#+RESULTS:

**** Solution

#+BEGIN_SRC j :results output value :tangle src/day12.ijs
assert 118242 = part2 in=. getin 'inputs/day-12.txt'
#+END_SRC

#+RESULTS:

** [[https://adventofcode.com/2021/day/13][Day 13: Transparent Origami]]

#+TOC: headlines 2 local
*** Setup

#+BEGIN_SRC j :results output silent
cocurrent <'day13'
#+END_SRC

#+BEGIN_SRC j :results output silent :tangle src/day13.ijs
load <'utils.ijs'  NB. readin
#+END_SRC

*** Approach 1

This approach closely follows [[https://www.youtube.com/watch?v=w15Z1xObd4U][Russ' Ivy-based solution]].

**** Read and process data

#+BEGIN_SRC j :results output silent :tangle src/day13.ijs
rplcxy=: rplc&('y=';'0 ';'x=';'';',';' ')
rawin=: 3 : '>&.> <;._1 (a: , ]) ({. ,&.> {:)"1 (".&.>) ;: rplcxy readin y'
#+END_SRC

=rawin= creates a 2-element boxed list,

1. The first element is the list of dots converted, after removing the =,= (comma) between the numbers, to a two-column integer array.
2. The second element is a two-column integer array of fold instructions as =(x, 0)= or =(0, y)= that is obtained after replacing ~y=~ with =0= and removing ~x=~. 

Since the fold instructions have to be applied recursively to the list of dots, it is convenient to recast the data into a structure conducive for the application of =/\.=.
The =procin= (/process input/) function below does exactly this.

#+BEGIN_SRC j :results output silent :tangle src/day13.ijs
procin=: <"1@|.@>@{:, {.
#+END_SRC

=getin= is thusly defined,

#+BEGIN_SRC j :results output silent :tangle src/day13.ijs
getin=: procin@rawin
#+END_SRC

#+BEGIN_SRC j :results output value :exports results
y=. 'inputs/day-13-example.txt'
(".&.> ,:~ ]) ('] readin y'; 'rawin y'; 'getin y')
#+END_SRC

#+RESULTS:
#+begin_example
┌──────────────┬───────────┬───────────────┐
│] readin y    │rawin y    │getin y        │
├──────────────┼───────────┼───────────────┤
│6,10          │┌─────┬───┐│┌───┬───┬─────┐│
│0,14          ││ 6 10│0 7│││5 0│0 7│ 6 10││
│9,10          ││ 0 14│5 0│││   │   │ 0 14││
│0,3           ││ 9 10│   │││   │   │ 9 10││
│10,4          ││ 0  3│   │││   │   │ 0  3││
│4,11          ││10  4│   │││   │   │10  4││
│6,0           ││ 4 11│   │││   │   │ 4 11││
│6,12          ││ 6  0│   │││   │   │ 6  0││
│4,1           ││ 6 12│   │││   │   │ 6 12││
│0,13          ││ 4  1│   │││   │   │ 4  1││
│10,12         ││ 0 13│   │││   │   │ 0 13││
│3,4           ││10 12│   │││   │   │10 12││
│3,0           ││ 3  4│   │││   │   │ 3  4││
│8,4           ││ 3  0│   │││   │   │ 3  0││
│1,10          ││ 8  4│   │││   │   │ 8  4││
│2,14          ││ 1 10│   │││   │   │ 1 10││
│8,10          ││ 2 14│   │││   │   │ 2 14││
│9,0           ││ 8 10│   │││   │   │ 8 10││
│              ││ 9  0│   │││   │   │ 9  0││
│fold along y=7│└─────┴───┘│└───┴───┴─────┘│
│fold along x=5│           │               │
└──────────────┴───────────┴───────────────┘
#+end_example

**** General function definition

***** Fold

#+BEGIN_SRC j :results output silent :tangle src/day13.ijs 
NB. Fold point x across y
fold=: (] - |@:-~)`[@.(0: = ])
#+END_SRC

#+BEGIN_SRC j :results output value :exports results
(".&.> ,:~ ]) ('5 fold 3'; '8 fold 6'; '3 fold 0'; '0 fold 4')
#+END_SRC

#+RESULTS:
: ┌────────┬────────┬────────┬────────┐
: │5 fold 3│8 fold 6│3 fold 0│0 fold 4│
: ├────────┼────────┼────────┼────────┤
: │1       │4       │3       │0       │
: └────────┴────────┴────────┴────────┘

***** Origami

#+BEGIN_SRC j :results output silent :tangle src/day13.ijs
NB. Recursively apply folds x to series of points y
origami=: ((fold"0)~"1/)&.>/\.
#+END_SRC

***** Marks

#+BEGIN_SRC j :results output silent :tangle src/day13.ijs
NB. Creates grid of 0s with 1s (marks) at locations of points in y
marks=: 3 : '1 (|.&.> <"1 y) } (0 * i. |. >: >./ y)'
#+END_SRC

#+BEGIN_SRC j :results output value :exports results
yl=. (1 0, 3 1, 2 2, 1 3 ,: 2 4)
y=. }. {.&.>/\. ((<yl) ,~  (<"0 i.5))
(; 5 # <('y'; 'marks y')) ,: , |: y ,: marks &.> y
#+END_SRC

#+RESULTS:
: ┌───┬───────┬───┬───────┬───┬───────┬───┬───────┬───┬───────┐
: │y  │marks y│y  │marks y│y  │marks y│y  │marks y│y  │marks y│
: ├───┼───────┼───┼───────┼───┼───────┼───┼───────┼───┼───────┤
: │1 0│0 1    │1 0│0 1 0 0│1 0│0 1 0 0│1 0│0 1 0 0│1 0│0 1 0 0│
: │   │       │3 1│0 0 0 1│3 1│0 0 0 1│3 1│0 0 0 1│3 1│0 0 0 1│
: │   │       │   │       │2 2│0 0 1 0│2 2│0 0 1 0│2 2│0 0 1 0│
: │   │       │   │       │   │       │1 3│0 1 0 0│1 3│0 1 0 0│
: │   │       │   │       │   │       │   │       │2 4│0 0 1 0│
: └───┴───────┴───┴───────┴───┴───────┴───┴───────┴───┴───────┘

**** Part 1

***** Function definition

#+BEGIN_SRC j :results output silent :tangle src/day13.ijs
part1=: 3 : '+/ ~: > _2&{ origami y'
#+END_SRC

***** Test

 #+BEGIN_SRC j :results output value :tangle src/day13.ijs
assert 17 = part1 inx=. getin 'inputs/day-13-example.txt'
 #+END_SRC

 #+RESULTS:

***** Solution

 #+BEGIN_SRC j :results output value :tangle src/day13.ijs
assert 827 = part1 in=. getin 'inputs/day-13.txt'
 #+END_SRC

 #+RESULTS:

**** Part 2

***** Function definition

 #+BEGIN_SRC j :results output silent :tangle src/day13.ijs
part2=: 3 : '_ * -. >  marks ~. > @ {. origami y'
 #+END_SRC

***** Solution

 #+BEGIN_SRC j :results output value :exports both :tangle src/day13.ijs
part2 in=. getin 'inputs/day-13.txt' NB. EAHKRECP
 #+END_SRC

 #+RESULTS:
 : 0 0 0 0 _ _ 0 0 _ _ 0 _ _ 0 _ 0 _ _ 0 _ 0 0 0 _ _ 0 0 0 0 _ _ 0 0 _ _ 0 0 0 _
 : 0 _ _ _ _ 0 _ _ 0 _ 0 _ _ 0 _ 0 _ 0 _ _ 0 _ _ 0 _ 0 _ _ _ _ 0 _ _ 0 _ 0 _ _ 0
 : 0 0 0 _ _ 0 _ _ 0 _ 0 0 0 0 _ 0 0 _ _ _ 0 _ _ 0 _ 0 0 0 _ _ 0 _ _ _ _ 0 _ _ 0
 : 0 _ _ _ _ 0 0 0 0 _ 0 _ _ 0 _ 0 _ 0 _ _ 0 0 0 _ _ 0 _ _ _ _ 0 _ _ _ _ 0 0 0 _
 : 0 _ _ _ _ 0 _ _ 0 _ 0 _ _ 0 _ 0 _ 0 _ _ 0 _ 0 _ _ 0 _ _ _ _ 0 _ _ 0 _ 0 _ _ _
 : 0 0 0 0 _ 0 _ _ 0 _ 0 _ _ 0 _ 0 _ _ 0 _ 0 _ _ 0 _ 0 0 0 0 _ _ 0 0 _ _ 0 _ _ _
 
*** Approach 2

This approach follows that laid out in the problem.

**** Read and process data

***** Raw input

#+BEGIN_SRC j :results output silent :tangle src/day13.ijs
rplcxy=: rplc&('y=';'_';'x=';'';',';' ')
rawin=: 3 : '>&.> <;._1 (a: , ]) ({. ,&.> {:)"1 (".&.>) ;: rplcxy readin y'
#+END_SRC

=rawin= creates a 2-element boxed list,

1. The first element is the list of dots converted, after removing the =,= (comma) between the numbers, to a two-column integer array.
2. The second element is an integer array of fold instructions with the convention that negative numbers are used to denote folds along =y= 
(the convention of [[*Approach 1]] could also have been used but this is simpler).

***** Points to grid 

#+BEGIN_SRC j :results output silent :tangle src/day13.ijs
NB. Creates grid of 0s with 1s (marks) at locations of points in y
marks=: 3 : '1 (|.&.> <"1 y) } (0 * i. |. >: >./ y)'
#+END_SRC

As in [[*Approach 1]], the =marks= function expands a set of =(x, y)= points on a (boolean) grid,

#+BEGIN_SRC j :results output value :exports results
yl=. (1 0, 3 1, 2 2, 1 3 ,: 2 4)
y=. }. {.&.>/\. ((<yl) ,~  (<"0 i.5))
(; 5 # <('y'; 'marks y')) ,: , |: y ,: marks &.> y
#+END_SRC

#+RESULTS:
: ┌───┬───────┬───┬───────┬───┬───────┬───┬───────┬───┬───────┐
: │y  │marks y│y  │marks y│y  │marks y│y  │marks y│y  │marks y│
: ├───┼───────┼───┼───────┼───┼───────┼───┼───────┼───┼───────┤
: │1 0│0 1    │1 0│0 1 0 0│1 0│0 1 0 0│1 0│0 1 0 0│1 0│0 1 0 0│
: │   │       │3 1│0 0 0 1│3 1│0 0 0 1│3 1│0 0 0 1│3 1│0 0 0 1│
: │   │       │   │       │2 2│0 0 1 0│2 2│0 0 1 0│2 2│0 0 1 0│
: │   │       │   │       │   │       │1 3│0 1 0 0│1 3│0 1 0 0│
: │   │       │   │       │   │       │   │       │2 4│0 0 1 0│
: └───┴───────┴───┴───────┴───┴───────┴───┴───────┴───┴───────┘

***** Get input

Since the folds are to be applied recursively, =getin= casts the data in a format conducive for the application of =/\.=

#+BEGIN_SRC j :results output silent :tangle src/day13.ijs
getin=: 3 : '(;/@,@|.@(] + *) i) , <(marks d) [ ''d i''=. rawin y'
#+END_SRC

Indexing starts at zero, so magnitudes of both the =x= (positive) and =y= (negative) fold instructions are incremented (=(] + *) i=).

#+BEGIN_SRC j :results output value :exports results
y=. 'inputs/day-13-example.txt'
(".&.> ,:~ ]) ('] readin y'; 'getin y')
#+END_SRC

#+RESULTS:
#+begin_example
┌──────────────┬────────────────────────────┐
│] readin y    │getin y                     │
├──────────────┼────────────────────────────┤
│6,10          │┌─┬──┬─────────────────────┐│
│0,14          ││6│_8│0 0 0 1 0 0 1 0 0 1 0││
│9,10          ││ │  │0 0 0 0 1 0 0 0 0 0 0││
│0,3           ││ │  │0 0 0 0 0 0 0 0 0 0 0││
│10,4          ││ │  │1 0 0 0 0 0 0 0 0 0 0││
│4,11          ││ │  │0 0 0 1 0 0 0 0 1 0 1││
│6,0           ││ │  │0 0 0 0 0 0 0 0 0 0 0││
│6,12          ││ │  │0 0 0 0 0 0 0 0 0 0 0││
│4,1           ││ │  │0 0 0 0 0 0 0 0 0 0 0││
│0,13          ││ │  │0 0 0 0 0 0 0 0 0 0 0││
│10,12         ││ │  │0 0 0 0 0 0 0 0 0 0 0││
│3,4           ││ │  │0 1 0 0 0 0 1 0 1 1 0││
│3,0           ││ │  │0 0 0 0 1 0 0 0 0 0 0││
│8,4           ││ │  │0 0 0 0 0 0 1 0 0 0 1││
│1,10          ││ │  │1 0 0 0 0 0 0 0 0 0 0││
│2,14          ││ │  │1 0 1 0 0 0 0 0 0 0 0││
│8,10          │└─┴──┴─────────────────────┘│
│9,0           │                            │
│              │                            │
│fold along y=7│                            │
│fold along x=5│                            │
└──────────────┴────────────────────────────┘
#+end_example

**** General function definitions

***** ❖ Fold

A generic function to fold along any axis is defined as,

#+BEGIN_SRC j :results output silent :tangle src/day13.ijs 
NB. Conjunction to split boolean matrix y by u and v across x and 
NB. join resulting submatrices
NB. y = input matrix
NB. x = integer (fold along)
NB. u, v = 'selection' verbs => {., }., {:, }:, m&}
fold=: 2 : '|.@(+./)@(u ,: v)~'
#+END_SRC

=fold= is defined to be consistent with the adapted [[*Conventions]].

This conjunction makes use of the auto fill property of [[https://code.jsoftware.com/wiki/Vocabulary/commaco#dyadic][laminate]],

#+BEGIN_SRC j :results output value :exports results
y=. 4 3 $ 2 < ?.12#6
(".&.> ,:~ ]) ('y'; '(}. y) ,: ({. y)')
#+END_SRC

#+RESULTS:
#+begin_example
┌─────┬────────────────┐
│y    │(}. y) ,: ({. y)│
├─────┼────────────────┤
│0 0 1│0 1 1           │
│0 1 1│1 1 0           │
│1 1 0│0 1 0           │
│0 1 0│                │
│     │0 0 1           │
│     │0 0 0           │
│     │0 0 0           │
└─────┴────────────────┘
#+end_example

that is, =,:= can be used to split the rows or columns of the matrix into separate sub-matrices of the same size.

***** Horizontal and vertical folds

The horizontal fold is now easily defined by providing the appropriate =u= and =v=,

#+BEGIN_SRC j :results output silent :tangle src/day13.ijs
NB. Fold boolean matrix y along rows x
foldh=: |.@}:@{. fold }.
#+END_SRC


#+BEGIN_SRC j :results output value :exports results
y=. 8 5 $ 2 < ?.12#6
NB. (".&.> ,:~ ]) ('y'; '5 foldh y'; '6 foldh y')
(".&.> ,:~ ]) ('y'; 'y foldh 5'; 'y foldh 6')
#+END_SRC

#+RESULTS:
#+begin_example
┌─────────┬─────────┬─────────┐
│y        │y foldh 5│y foldh 6│
├─────────┼─────────┼─────────┤
│0 0 1 0 1│0 0 1 0 1│0 0 1 0 1│
│1 1 1 0 0│1 1 1 1 0│1 1 1 0 0│
│1 0 0 0 1│1 1 0 0 1│1 0 0 0 1│
│0 1 1 1 1│0 1 1 1 1│0 1 1 1 1│
│0 0 1 0 0│         │1 1 1 0 1│
│0 1 0 1 1│         │         │
│1 1 0 0 1│         │         │
│0 0 0 1 0│         │         │
└─────────┴─────────┴─────────┘
#+end_example

Note that =foldh= works as expected only for =x >: (# y)=.

The vertical fold is the horizontal fold on the transposed matrix,

#+BEGIN_SRC j :results output silent :tangle src/day13.ijs
NB. Fold boolean matrix x along columns y
foldv=: foldh&.|: 
#+END_SRC

Lastly, by the convention adopted above, vertical folds are applied to the positive instructions and horizontal folds to the negative instructions,

#+BEGIN_SRC j :results output silent :tangle src/day13.ijs
NB. Fold boolean matrix y along column or row x
foldvh=: foldv`([ foldh |@]) @. (0: > ])
#+END_SRC

***** Origami

#+BEGIN_SRC j :results output silent :tangle src/day13.ijs
NB. Recursively apply folds x to boolean matrix y
origami=: (foldvh~)&.>/\.
#+END_SRC

**** Part 1

***** Function definition

#+BEGIN_SRC j :results output silent :tangle src/day13.ijs
part1=: 3 : '+/ , > (_2&{) origami y'
#+END_SRC

***** Test

#+BEGIN_SRC j :results output value :tangle src/day13.ijs
assert 17 = part1 inx=. getin 'inputs/day-13-example.txt'
#+END_SRC

#+RESULTS:

***** Solution

#+BEGIN_SRC j :results output value :tangle src/day13.ijs
assert 827 = part1 in=. getin 'inputs/day-13.txt'
#+END_SRC

 #+RESULTS:

**** Part 2

***** Function definition

#+BEGIN_SRC j :results output silent :tangle src/day13.ijs
part2=: 3 : '_ * -. > @ {. origami y'
#+END_SRC

***** Solution

#+BEGIN_SRC j :results output value :exports both :tangle src/day13.ijs
part2 in=. getin 'inputs/day-13.txt'  NB. EAHKRECP
#+END_SRC

 #+RESULTS:
 : 0 0 0 0 _ _ 0 0 _ _ 0 _ _ 0 _ 0 _ _ 0 _ 0 0 0 _ _ 0 0 0 0 _ _ 0 0 _ _ 0 0 0 _ _
 : 0 _ _ _ _ 0 _ _ 0 _ 0 _ _ 0 _ 0 _ 0 _ _ 0 _ _ 0 _ 0 _ _ _ _ 0 _ _ 0 _ 0 _ _ 0 _
 : 0 0 0 _ _ 0 _ _ 0 _ 0 0 0 0 _ 0 0 _ _ _ 0 _ _ 0 _ 0 0 0 _ _ 0 _ _ _ _ 0 _ _ 0 _
 : 0 _ _ _ _ 0 0 0 0 _ 0 _ _ 0 _ 0 _ 0 _ _ 0 0 0 _ _ 0 _ _ _ _ 0 _ _ _ _ 0 0 0 _ _
 : 0 _ _ _ _ 0 _ _ 0 _ 0 _ _ 0 _ 0 _ 0 _ _ 0 _ 0 _ _ 0 _ _ _ _ 0 _ _ 0 _ 0 _ _ _ _
 : 0 0 0 0 _ 0 _ _ 0 _ 0 _ _ 0 _ 0 _ _ 0 _ 0 _ _ 0 _ 0 0 0 0 _ _ 0 0 _ _ 0 _ _ _ _
 
** [[https://adventofcode.com/2021/day/14][Day 14: Extended Polymerization]]                                            

#+TOC: headlines 2 local

*** Setup

#+BEGIN_SRC j :results output silent
cocurrent <'day14'
#+END_SRC

#+BEGIN_SRC j :results output silent :tangle src/day14.ijs
load <'utils.ijs'  NB. readin
#+END_SRC

*** Read data

#+BEGIN_SRC j :results output silent :tangle src/day14.ijs
getin=: ((0&{::)@{.@] ; <@([: _2&(<\)"1 [: (0 1 0 6 6 1 { ])&> 2&}.))@(<"1 readin@])
#+END_SRC

=getin= creates a 2-element boxed list,

+ The first element is the template string.
+ The second element is a 3-column boxed array of the /expanded/ rules,
    - The first column is the *source-molecule-pairs*
    - The second and third columns are the corresponding *reaction-product-molecule-pairs*,

#+BEGIN_SRC j :results output value :exports results
y=. 'inputs/day-14-example.txt'
(".&.> ,:~ ]) ('] readin y'; 'getin y')
#+END_SRC

#+RESULTS:
#+begin_example
┌──────────┬─────────────────┐
│] readin y│getin y          │
├──────────┼─────────────────┤
│NNCB      │┌────┬──────────┐│
│          ││NNCB│┌──┬──┬──┐││
│CH -> B   ││    ││CH│CB│BH│││
│HH -> N   ││    │├──┼──┼──┤││
│CB -> H   ││    ││HH│HN│NH│││
│NH -> C   ││    │├──┼──┼──┤││
│HB -> C   ││    ││CB│CH│HB│││
│HC -> B   ││    │├──┼──┼──┤││
│HN -> C   ││    ││NH│NC│CH│││
│NN -> C   ││    │├──┼──┼──┤││
│BH -> H   ││    ││HB│HC│CB│││
│NC -> B   ││    │├──┼──┼──┤││
│NB -> B   ││    ││HC│HB│BC│││
│BN -> B   ││    │├──┼──┼──┤││
│BB -> N   ││    ││HN│HC│CN│││
│BC -> B   ││    │├──┼──┼──┤││
│CC -> N   ││    ││NN│NC│CN│││
│CN -> C   ││    │├──┼──┼──┤││
│          ││    ││BH│BH│HH│││
│          ││    │├──┼──┼──┤││
│          ││    ││NC│NB│BC│││
│          ││    │├──┼──┼──┤││
│          ││    ││NB│NB│BB│││
│          ││    │├──┼──┼──┤││
│          ││    ││BN│BB│BN│││
│          ││    │├──┼──┼──┤││
│          ││    ││BB│BN│NB│││
│          ││    │├──┼──┼──┤││
│          ││    ││BC│BB│BC│││
│          ││    │├──┼──┼──┤││
│          ││    ││CC│CN│NC│││
│          ││    │├──┼──┼──┤││
│          ││    ││CN│CC│CN│││
│          ││    │└──┴──┴──┘││
│          │└────┴──────────┘│
└──────────┴─────────────────┘
#+end_example

*** General function definitions

This problem is almost identical to [[https://adventofcode.com/2021/day/6][Day 06: Lanternfish]] , except that the stochastic matrix now has to be constructed automatically.

***** Stochastic matrix

The (transpose of) stochastic matrix is obtained by looking up the positions of the product-pairs in the source-pair sequence,

#+BEGIN_SRC j :results output silent :tangle src/day14.ijs 
NB. Create a stochastic matrix from y
NB. y = boxed table of rules
NB.     column 1 = source molecule pairs
NB.     column 2 and 3 = product molecule pairs
stoctrix=: [: |: {."1 e./"1 }."1
#+END_SRC

For the example in the problem, the stochastic matrix is,

#+BEGIN_SRC j :results output value :exports results
't r'=. getin 'inputs/day-14-example.txt'
stoctrix r
#+END_SRC

#+RESULTS:
#+begin_example
0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0
1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0
0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0
0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0
0 0 0 1 0 0 0 1 0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 0 0 1 1 0 1 0 0 0
0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0
0 0 0 0 0 0 0 0 0 0 1 1 0 1 0 0
0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1
0 0 0 0 0 0 1 1 0 0 0 0 0 0 1 1
#+end_example

This is better visualized with the source-pair labels,

#+BEGIN_SRC j :results output value :exports results
't r'=. getin 'inputs/day-14-example.txt'
(a: , |: {."1 r) ,. (|: {."1 r) , (<"0 stoctrix r)
#+END_SRC

#+RESULTS:
#+begin_example
┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐
│  │CH│HH│CB│NH│HB│HC│HN│NN│BH│NC│NB│BN│BB│BC│CC│CN│
├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
│CH│0 │0 │1 │1 │0 │0 │0 │0 │0 │0 │0 │0 │0 │0 │0 │0 │
├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
│HH│0 │0 │0 │0 │0 │0 │0 │0 │1 │0 │0 │0 │0 │0 │0 │0 │
├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
│CB│1 │0 │0 │0 │1 │0 │0 │0 │0 │0 │0 │0 │0 │0 │0 │0 │
├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
│NH│0 │1 │0 │0 │0 │0 │0 │0 │0 │0 │0 │0 │0 │0 │0 │0 │
├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
│HB│0 │0 │1 │0 │0 │1 │0 │0 │0 │0 │0 │0 │0 │0 │0 │0 │
├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
│HC│0 │0 │0 │0 │1 │0 │1 │0 │0 │0 │0 │0 │0 │0 │0 │0 │
├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
│HN│0 │1 │0 │0 │0 │0 │0 │0 │0 │0 │0 │0 │0 │0 │0 │0 │
├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
│NN│0 │0 │0 │0 │0 │0 │0 │0 │0 │0 │0 │0 │0 │0 │0 │0 │
├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
│BH│1 │0 │0 │0 │0 │0 │0 │0 │1 │0 │0 │0 │0 │0 │0 │0 │
├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
│NC│0 │0 │0 │1 │0 │0 │0 │1 │0 │0 │0 │0 │0 │0 │1 │0 │
├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
│NB│0 │0 │0 │0 │0 │0 │0 │0 │0 │1 │1 │0 │1 │0 │0 │0 │
├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
│BN│0 │0 │0 │0 │0 │0 │0 │0 │0 │0 │0 │1 │1 │0 │0 │0 │
├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
│BB│0 │0 │0 │0 │0 │0 │0 │0 │0 │0 │1 │1 │0 │1 │0 │0 │
├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
│BC│0 │0 │0 │0 │0 │1 │0 │0 │0 │1 │0 │0 │0 │1 │0 │0 │
├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
│CC│0 │0 │0 │0 │0 │0 │0 │0 │0 │0 │0 │0 │0 │0 │0 │1 │
├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
│CN│0 │0 │0 │0 │0 │0 │1 │1 │0 │0 │0 │0 │0 │0 │1 │1 │
└──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘
#+end_example

Column =CH= has ones in locations of =CB= and =BH=, since =CH -> CB, BH=. Column =HH= has ones in locations of =HN= and =NH=, 
since =HH -> HN, NH= and so on for each rule.

***** Response (template) matrix

#+BEGIN_SRC j :results output silent :tangle src/day14.ijs 
NB. Create response vectors for each template pair
NB. y = template string
NB. x = source molecule pairs
tmpltrix=: ({."1)@[ e./"1 0 (2&(<\)@])
#+END_SRC

The problem is linearly separable, so each template-pair can be expanded independently and the results accumulated at the end.

=templtrix= finds locations of each of the template-pairs in the source-pairs,

#+BEGIN_SRC j :results output value :exports results
't r'=. getin 'inputs/day-14-example.txt'
r tmpltrix t
#+END_SRC

#+RESULTS:
: 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0
: 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0
: 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0

which is better visualized with both the source-pair and template-pair labels,

#+BEGIN_SRC j :results output value :exports results
't r'=. getin 'inputs/day-14-example.txt'
(a: , {."1 r) , (2&(<\) t) ,. (<"0 r tmpltrix t)
#+END_SRC

#+RESULTS:
: ┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐
: │  │CH│HH│CB│NH│HB│HC│HN│NN│BH│NC│NB│BN│BB│BC│CC│CN│
: ├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
: │NN│0 │0 │0 │0 │0 │0 │0 │1 │0 │0 │0 │0 │0 │0 │0 │0 │
: ├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
: │NC│0 │0 │0 │0 │0 │0 │0 │0 │0 │1 │0 │0 │0 │0 │0 │0 │
: ├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
: │CB│0 │0 │1 │0 │0 │0 │0 │0 │0 │0 │0 │0 │0 │0 │0 │0 │
: └──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘

This approach (of creating response vectors for each individual template-pair) works even when the template string contains duplicate pairs.

***** Matrix operations

#+BEGIN_SRC j :results output silent :tangle src/day14.ijs 
NB. Matrix product
mp=: +/ . *
#+END_SRC

#+BEGIN_SRC j :results output silent :tangle src/day14.ijs 
NB. Raise matrix to nth power
mpow=: 4 : 'mp/ mp~^:(I.|.#:y) x'
#+END_SRC

***** Polymerize reaction

#+BEGIN_SRC j :results output silent :tangle src/day14.ijs 
NB. Get count of reaction products for each template-pair 
NB. using rules for y generations
NB. y = number of generations
NB. x = two-element boxed array (as returned by 'getin')
NB.     first element = template string
NB.     second element = 3-column boxed table of rules
polymerize=: 4 : '(((stoctrix r) mpow y) mp ])"1 (r tmpltrix t) [ ''t r''=. x' NB. t = template, r = rules
#+END_SRC

#+BEGIN_SRC j :results output value :exports results
y=. getin 'inputs/day-14-example.txt'
(".&.> ,.~ ]) ('y polymerize 1'; 'y polymerize 5'; 'y polymerize 10')
#+END_SRC

#+RESULTS:
#+begin_example
┌───────────────┬──────────────────────────────────────────────────┐
│y polymerize 1 │0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1                   │
│               │0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0                   │
│               │1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0                   │
├───────────────┼──────────────────────────────────────────────────┤
│y polymerize 5 │0 0 0 0 0 0 0 0 0 2  7  4  8 3 3 5                │
│               │0 0 0 0 0 0 0 0 0 0 11 10 10 1 0 0                │
│               │6 3 0 1 8 1 1 0 3 1  1  1  1 4 0 1                │
├───────────────┼──────────────────────────────────────────────────┤
│y polymerize 10│ 0  0   0  0  0  0  0 0  0 21 308 274 298 34 34 55│
│               │ 0  0   0  0  0  0  0 0  0  0 341 340 342  1  0  0│
│               │21 32 115 27 26 76 27 0 81 21 147 121 172 85 26 47│
└───────────────┴──────────────────────────────────────────────────┘
#+end_example

***** Summarize element counts

#+BEGIN_SRC j :results output silent :tangle src/day14.ijs 
NB. Summarize count of elements in source molecule pairs after y generations
NB. y = number of generations
NB. x = two-element boxed array (as returned by 'getin')
NB.     first element = template string
NB.     second element = 3-column boxed table of rules
summarize=: 4 : '(r addendum t) + ({.&.> {."1 r) +//. y [ ''t r''=. x' NB. t = template, r = rules
#+END_SRC

where,

#+BEGIN_SRC j :results output silent :tangle src/day14.ijs 
NB. Finds last element of template string in source molecule pairs
NB. Used in 'summarize' function
NB. y = template string
NB. x = 3-column boxed table of rules
addendum=: ([: ~. ({.&.>)@({."1)@[) e. {:@(;/)@]
#+END_SRC

The element counts can be obtained either from the first or last elements of the source molecule pairs. =summarize= uses the first (head), 
of the source molecule pairs,

#+BEGIN_SRC j :results output value :exports results
't r'=. y=. getin 'inputs/day-14-example.txt'
({.&.> ,:~ ]) {."1 r
#+END_SRC

#+RESULTS:
: ┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐
: │CH│HH│CB│NH│HB│HC│HN│NN│BH│NC│NB│BN│BB│BC│CC│CN│
: ├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
: │C │H │C │N │H │H │H │N │B │N │N │B │B │B │C │C │
: └──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘

However, this will miss the single count from the /last/ element in the template string. =addendum= finds this,

#+BEGIN_SRC j :results output value :exports results
't r'=. y=. getin 'inputs/day-14-example.txt'
(".&.> ,.~ ]) ('t'; ', {."1 r'; '~. {.&.> {."1 r'; ';/ t'; 'r addendum t')
#+END_SRC

#+RESULTS:
#+begin_example
┌───────────────┬─────────────────────────────────────────────────┐
│t              │NNCB                                             │
├───────────────┼─────────────────────────────────────────────────┤
│, {."1 r       │┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐│
│               ││CH│HH│CB│NH│HB│HC│HN│NN│BH│NC│NB│BN│BB│BC│CC│CN││
│               │└──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘│
├───────────────┼─────────────────────────────────────────────────┤
│~. {.&.> {."1 r│┌─┬─┬─┬─┐                                        │
│               ││C│H│N│B│                                        │
│               │└─┴─┴─┴─┘                                        │
├───────────────┼─────────────────────────────────────────────────┤
│;/ t           │┌─┬─┬─┬─┐                                        │
│               ││N│N│C│B│                                        │
│               │└─┴─┴─┴─┘                                        │
├───────────────┼─────────────────────────────────────────────────┤
│r addendum t   │0 0 0 1                                          │
└───────────────┴─────────────────────────────────────────────────┘
#+end_example

and adds it to the summary.

Note that if the last elements of the source molecule pairs had been used, then the count from the /first/ element of the template string would
have to be added back to the summary.

***** Range

#+BEGIN_SRC j :results output silent :tangle src/day14.ijs
NB. Finds range (max - min) of element counts after y generations
NB. y = number of generations
NB. x = input as returned by getin
NB.     first element = template string
NB.     second element = 3-column boxed table of rules        
range=: [: (>./ - <./) [: (] #~ 0: < ]) [ summarize +/@:polymerize
#+END_SRC


*** Part 1

**** Function definition

#+BEGIN_SRC j :results output silent :tangle src/day14.ijs
part1=: range&10
#+END_SRC

**** Test

#+BEGIN_SRC j :results output value :tangle src/day14.ijs
assert 1588 = part1 inx=. getin 'inputs/day-14-example.txt'
#+END_SRC

#+RESULTS:

**** Solution

#+BEGIN_SRC j :results output value :tangle src/day14.ijs
assert 3406 = part1 in=. getin 'inputs/day-14.txt'
#+END_SRC

#+RESULTS:

*** Part 2

**** Function definition

#+BEGIN_SRC j :results output silent :tangle src/day14.ijs
part2=: range&40
#+END_SRC

**** Test

#+BEGIN_SRC j :results output value :tangle src/day14.ijs
assert 2188189693529 = part2 inx=. getin 'inputs/day-14-example.txt'
#+END_SRC

#+RESULTS:

**** Solution

#+BEGIN_SRC j :results output value :tangle src/day14.ijs
assert 3941782230241 = part2 in=. getin 'inputs/day-14.txt'
#+END_SRC

#+RESULTS:


** [[https://adventofcode.com/2021/day/x][Day 0X: Template]]                                                :noexport:

#+TOC: headlines 2 local

*** Setup

#+BEGIN_SRC j :results output silent
cocurrent <'day0x'
#+END_SRC

#+BEGIN_SRC j :results output silent :tangle src/day0x.ijs
load <'utils.ijs'  NB. readin
#+END_SRC

*** Read data

#+BEGIN_SRC j :results output silent :tangle src/day0x.ijs
getin=: ". readin
#+END_SRC


*** General function definition

Generic function to calculate number of increases in data for a given moving window size,
#+BEGIN_SRC j :results output silent :tangle src/day0x.ijs 
f=: 1:
#+END_SRC

*** Part 1

**** Function definition

#+BEGIN_SRC j :results output silent :tangle src/day0x.ijs
part1=: 1:
#+END_SRC

**** Test

#+BEGIN_SRC j :results output value :tangle src/day0x.ijs
assert 1 = part1 inx=. getin 'inputs/day-0x-example.txt'
#+END_SRC

#+RESULTS:

**** Solution

#+BEGIN_SRC j :results output value :tangle src/day0x.ijs
assert 1111 = part1 in=. getin 'inputs/day-0x.txt'
#+END_SRC

#+RESULTS:

*** Part 2

**** Function definition

#+BEGIN_SRC j :results output silent :tangle src/day0x.ijs
part2=: 2:
#+END_SRC

**** Test

#+BEGIN_SRC j :results output value :tangle src/day0x.ijs
assert 2 = part1 inx=. getin 'inputs/day-0x-example.txt'
#+END_SRC

#+RESULTS:

**** Solution

#+BEGIN_SRC j :results output value :tangle src/day0x.ijs
assert 2222 = part2 in=. getin 'inputs/day-0x.txt'
#+END_SRC

#+RESULTS:

